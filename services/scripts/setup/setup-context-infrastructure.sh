#!/bin/bash

# IRIS v2.0 Context Memory Infrastructure Setup Script
# Phase 1: Context Memory Infrastructure
# Author: MiniMax Agent
# Created: 2025-11-10

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="IRIS v2.0 Context Memory Infrastructure"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INFRASTRUCTURE_DIR="$SCRIPT_DIR/../.."
LOG_FILE="$INFRASTRUCTURE_DIR/logs/setup.log"

# Create logs directory
mkdir -p "$INFRASTRUCTURE_DIR/logs"

# Function to log messages
log() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} - ${message}" | tee -a "$LOG_FILE"
}

# Function to print colored output
print_status() {
    local color="$1"
    local message="$2"
    echo -e "${color}${message}${NC}"
    log "$message"
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to check system requirements
check_requirements() {
    print_status "$BLUE" "üîç Checking system requirements..."
    
    local requirements_met=true
    
    # Check Docker
    if command_exists docker; then
        print_status "$GREEN" "‚úÖ Docker is installed: $(docker --version)"
    else
        print_status "$RED" "‚ùå Docker is not installed. Please install Docker first."
        requirements_met=false
    fi
    
    # Check Docker Compose
    if command_exists docker-compose || docker compose version >/dev/null 2>&1; then
        print_status "$GREEN" "‚úÖ Docker Compose is available"
    else
        print_status "$RED" "‚ùå Docker Compose is not installed. Please install Docker Compose first."
        requirements_met=false
    fi
    
    # Check available memory
    local available_memory=$(free -m | awk 'NR==2{print $7}')
    if [ "$available_memory" -gt 4000 ]; then
        print_status "$GREEN" "‚úÖ Sufficient memory available: ${available_memory}MB"
    else
        print_status "$YELLOW" "‚ö†Ô∏è  Low memory available: ${available_memory}MB. Recommended: 4GB+"
    fi
    
    # Check disk space
    local available_disk=$(df -BG . | awk 'NR==2{print $4}' | sed 's/G//')
    if [ "$available_disk" -gt 20 ]; then
        print_status "$GREEN" "‚úÖ Sufficient disk space: ${available_disk}GB"
    else
        print_status "$YELLOW" "‚ö†Ô∏è  Limited disk space: ${available_disk}GB. Recommended: 20GB+"
    fi
    
    if [ "$requirements_met" = false ]; then
        print_status "$RED" "‚ùå System requirements not met. Please install missing dependencies."
        exit 1
    fi
    
    print_status "$GREEN" "‚úÖ All system requirements met!"
}

# Function to create environment file
create_env_file() {
    print_status "$BLUE" "üìù Creating environment configuration..."
    
    local env_file="$INFRASTRUCTURE_DIR/.env"
    
    if [ ! -f "$env_file" ]; then
        cat > "$env_file" << 'EOF'
# IRIS v2.0 Context Memory Infrastructure Configuration
# Generated by setup script

# Database Configuration
DATABASE_URL=postgresql://iris_user:IrisSecure2025@postgres:5432/iris_context_db
POSTGRES_USER=iris_user
POSTGRES_PASSWORD=IrisSecure2025@Context
POSTGRES_DB=iris_context_db

# Neo4j Configuration
NEO4J_URI=bolt://neo4j:7687
NEO4J_USER=neo4j
NEO4J_PASSWORD=iris_secure_2025

# Redis Configuration
REDIS_URL=redis://:RedisSecure2025@redis:6379
REDIS_PASSWORD=RedisSecure2025@Context

# Kafka Configuration
KAFKA_BROKERS=kafka:9092
KAFKA_AUTO_CREATE_TOPICS_ENABLE=true
KAFKA_NUM_PARTITIONS=6

# OpenAI Configuration (Required)
OPENAI_API_KEY=your_openai_api_key_here

# Application Configuration
NODE_ENV=production
LOG_LEVEL=info
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:3001

# Service Configuration
CONTEXT_CAPTURE_PORT=8001
CONTEXT_PROCESSING_PORT=8002
CONTEXT_RETRIEVAL_PORT=8003
MEMORY_MANAGEMENT_PORT=8004

# Performance Configuration
MAX_CONNECTIONS=200
MAX_MEMORY_USAGE=4GB
VECTOR_INDEX_LISTS=100
EOF
        
        print_status "$GREEN" "‚úÖ Environment file created: $env_file"
        print_status "$YELLOW" "‚ö†Ô∏è  Please update OPENAI_API_KEY in the .env file before starting services."
    else
        print_status "$YELLOW" "‚ö†Ô∏è  Environment file already exists. Skipping creation."
    fi
}

# Function to set up database initialization
setup_database() {
    print_status "$BLUE" "üóÑÔ∏è  Setting up database initialization..."
    
    # Make initialization script executable
    chmod +x "$INFRASTRUCTURE_DIR/database/init/01_init_context_database.sh"
    
    # Create additional initialization scripts if needed
    print_status "$GREEN" "‚úÖ Database initialization scripts prepared"
}

# Function to build service images
build_services() {
    print_status "$BLUE" "üî® Building service images..."
    
    cd "$INFRASTRUCTURE_DIR"
    
    # Build each service
    services=("context-capture" "context-processing" "context-retrieval" "memory-management")
    
    for service in "${services[@]}"; do
        if [ -f "$INFRASTRUCTURE_DIR/services/$service/Dockerfile" ]; then
            print_status "$BLUE" "Building $service service..."
            docker build -t "iris-$service:2.0.0" "$INFRASTRUCTURE_DIR/services/$service/" >> "$LOG_FILE" 2>&1
            if [ $? -eq 0 ]; then
                print_status "$GREEN" "‚úÖ $service service built successfully"
            else
                print_status "$RED" "‚ùå Failed to build $service service"
                exit 1
            fi
        else
            print_status "$YELLOW" "‚ö†Ô∏è  No Dockerfile found for $service, skipping build"
        fi
    done
}

# Function to create Kafka topics
create_kafka_topics() {
    print_status "$BLUE" "üìä Setting up Kafka topics..."
    
    # Wait for Kafka to be ready
    print_status "$YELLOW" "‚è≥ Waiting for Kafka to be ready..."
    local kafka_ready=false
    local max_attempts=30
    local attempt=0
    
    while [ "$kafka_ready" = false ] && [ $attempt -lt $max_attempts ]; do
        if docker exec iris-kafka kafka-topics --bootstrap-server localhost:9092 --list >/dev/null 2>&1; then
            kafka_ready=true
            print_status "$GREEN" "‚úÖ Kafka is ready"
            break
        fi
        
        attempt=$((attempt + 1))
        print_status "$YELLOW" "‚è≥ Attempt $attempt/$max_attempts - Kafka not ready yet..."
        sleep 5
    done
    
    if [ "$kafka_ready" = false ]; then
        print_status "$RED" "‚ùå Kafka failed to become ready after $max_attempts attempts"
        return 1
    fi
    
    # Create topics
    local topics=(
        "iris.context.events:6:1:604800000"
        "iris.context.processed:4:1:2592000000"
        "iris.context.insights:3:1:31536000000"
        "iris.memory.management:2:1:864000000"
        "iris.knowledge.graph:3:1:31536000000"
        "iris.vector.search:2:1:864000000"
        "iris.context.retrieval:4:1:86400000"
        "iris.system.monitoring:1:1:2592000000"
        "iris.errors:2:1:7776000000"
        "iris.dead.letter:1:1:31536000000"
    )
    
    for topic_config in "${topics[@]}"; do
        IFS=':' read -r topic_name partitions replication retention <<< "$topic_config"
        
        print_status "$BLUE" "Creating topic: $topic_name"
        docker exec iris-kafka kafka-topics --create \
            --topic "$topic_name" \
            --bootstrap-server localhost:9092 \
            --partitions "$partitions" \
            --replication-factor "$replication" \
            --config "retention.ms=$retention" \
            --config "compression.type=gzip" \
            --config "cleanup.policy=delete" >> "$LOG_FILE" 2>&1
        
        if [ $? -eq 0 ]; then
            print_status "$GREEN" "‚úÖ Topic $topic_name created"
        else
            print_status "$RED" "‚ùå Failed to create topic $topic_name"
        fi
    done
}

# Function to start infrastructure
start_infrastructure() {
    print_status "$BLUE" "üöÄ Starting IRIS v2.0 Context Memory Infrastructure..."
    
    cd "$INFRASTRUCTURE_DIR"
    
    # Start the infrastructure
    docker-compose up -d
    
    if [ $? -eq 0 ]; then
        print_status "$GREEN" "‚úÖ Infrastructure started successfully"
    else
        print_status "$RED" "‚ùå Failed to start infrastructure"
        exit 1
    fi
}

# Function to wait for services to be healthy
wait_for_services() {
    print_status "$BLUE" "‚è≥ Waiting for services to be healthy..."
    
    local services=("postgres" "neo4j" "redis" "kafka")
    local max_attempts=60
    local attempt=0
    
    for service in "${services[@]}"; do
        print_status "$YELLOW" "Checking $service..."
        local service_ready=false
        
        while [ "$service_ready" = false ] && [ $attempt -lt $max_attempts ]; do
            if docker ps | grep -q "iris-$service.*Up"; then
                # Check specific health conditions
                case "$service" in
                    "postgres")
                        if docker exec iris-postgres-v2 pg_isready -U iris_user -d iris_context_db >/dev/null 2>&1; then
                            service_ready=true
                        fi
                        ;;
                    "neo4j")
                        if curl -s http://localhost:7474 >/dev/null 2>&1; then
                            service_ready=true
                        fi
                        ;;
                    "redis")
                        if docker exec iris-redis-v2 redis-cli ping | grep -q PONG; then
                            service_ready=true
                        fi
                        ;;
                    "kafka")
                        if docker exec iris-kafka kafka-topics --bootstrap-server localhost:9092 --list >/dev/null 2>&1; then
                            service_ready=true
                        fi
                        ;;
                esac
            fi
            
            if [ "$service_ready" = false ]; then
                attempt=$((attempt + 1))
                sleep 5
            fi
        done
        
        if [ "$service_ready" = true ]; then
            print_status "$GREEN" "‚úÖ $service is ready"
        else
            print_status "$RED" "‚ùå $service failed to become healthy"
        fi
    done
}

# Function to run health checks
run_health_checks() {
    print_status "$BLUE" "üîç Running health checks..."
    
    # Check service endpoints
    local endpoints=(
        "http://localhost:8001/health"
        "http://localhost:8002/health"
        "http://localhost:8003/health"
        "http://localhost:8004/health"
    )
    
    for endpoint in "${endpoints[@]}"; do
        local service_name=$(echo "$endpoint" | grep -o '[0-9]*' | head -1)
        print_status "$YELLOW" "Checking service on port $service_name..."
        
        local healthy=false
        local max_attempts=20
        local attempt=0
        
        while [ "$healthy" = false ] && [ $attempt -lt $max_attempts ]; do
            if curl -f -s "$endpoint" >/dev/null 2>&1; then
                healthy=true
                print_status "$GREEN" "‚úÖ Service on port $service_name is healthy"
            else
                attempt=$((attempt + 1))
                sleep 3
            fi
        done
        
        if [ "$healthy" = false ]; then
            print_status "$RED" "‚ùå Service on port $service_name is not responding"
        fi
    done
}

# Function to create test data
create_test_data() {
    print_status "$BLUE" "üìä Creating test data..."
    
    # Test data will be created automatically by the database initialization
    # For now, we'll create a simple test event
    
    local test_event='{
        "projectId": "00000000-0000-0000-0000-000000000001",
        "sessionId": "test-session-001",
        "actorId": "test-user",
        "type": "conversational",
        "content": "Testing the IRIS v2.0 context capture system. This should be processed and stored with semantic analysis."
    }'
    
    print_status "$YELLOW" "üß™ Sending test event to context capture service..."
    curl -X POST http://localhost:8001/api/v2/context/events \
        -H "Content-Type: application/json" \
        -d "$test_event" >> "$LOG_FILE" 2>&1
    
    if [ $? -eq 0 ]; then
        print_status "$GREEN" "‚úÖ Test event sent successfully"
    else
        print_status "$YELLOW" "‚ö†Ô∏è  Test event may have failed - check service logs"
    fi
}

# Function to display service information
display_service_info() {
    print_status "$GREEN" "üéâ IRIS v2.0 Context Memory Infrastructure setup completed!"
    echo
    print_status "$BLUE" "üìã Service Information:"
    echo "  ‚Ä¢ PostgreSQL (Context Events):        localhost:5432"
    echo "  ‚Ä¢ Neo4j (Knowledge Graph):            localhost:7474"
    echo "  ‚Ä¢ Redis (Caching):                    localhost:6379"
    echo "  ‚Ä¢ Kafka (Event Streaming):            localhost:9092"
    echo "  ‚Ä¢ Context Capture Service:            localhost:8001"
    echo "  ‚Ä¢ Context Processing Service:         localhost:8002"
    echo "  ‚Ä¢ Context Retrieval Service:          localhost:8003"
    echo "  ‚Ä¢ Memory Management Service:          localhost:8004"
    echo
    print_status "$BLUE" "üîß Management Commands:"
    echo "  ‚Ä¢ View logs:           docker-compose logs -f"
    echo "  ‚Ä¢ Stop services:       docker-compose down"
    echo "  ‚Ä¢ Restart services:    docker-compose restart"
    echo "  ‚Ä¢ Check status:        docker-compose ps"
    echo
    print_status "$YELLOW" "‚ö†Ô∏è  Important Notes:"
    echo "  ‚Ä¢ Update OPENAI_API_KEY in .env file before production use"
    echo "  ‚Ä¢ Configure proper security settings for production"
    echo "  ‚Ä¢ Monitor disk space for vector database growth"
    echo "  ‚Ä¢ Review and adjust Kafka retention policies as needed"
    echo
    print_status "$BLUE" "üìö Next Steps:"
    echo "  1. Configure environment variables in .env file"
    echo "  2. Set up monitoring and alerting"
    echo "  3. Test context capture and retrieval functionality"
    echo "  4. Begin Phase 2: MCP Integration & Project Organization"
    echo
    print_status "$GREEN" "üöÄ Infrastructure is ready for Phase 1 implementation!"
}

# Main setup function
main() {
    print_status "$GREEN" "üöÄ Starting $PROJECT_NAME setup..."
    echo
    
    # Check if running as root
    if [ "$EUID" -eq 0 ]; then
        print_status "$YELLOW" "‚ö†Ô∏è  Running as root. Consider using a regular user for security."
    fi
    
    # Create necessary directories
    mkdir -p "$INFRASTRUCTURE_DIR"/{logs,data,temp}
    
    # Run setup steps
    check_requirements
    create_env_file
    setup_database
    build_services
    start_infrastructure
    wait_for_services
    create_kafka_topics
    run_health_checks
    create_test_data
    display_service_info
    
    print_status "$GREEN" "‚úÖ Setup completed successfully!"
}

# Parse command line arguments
case "${1:-}" in
    "check")
        check_requirements
        ;;
    "env")
        create_env_file
        ;;
    "build")
        build_services
        ;;
    "start")
        start_infrastructure
        wait_for_services
        ;;
    "stop")
        cd "$INFRASTRUCTURE_DIR"
        docker-compose down
        ;;
    "logs")
        cd "$INFRASTRUCTURE_DIR"
        docker-compose logs -f
        ;;
    "health")
        run_health_checks
        ;;
    "clean")
        print_status "$YELLOW" "üßπ Cleaning up IRIS v2.0 infrastructure..."
        cd "$INFRASTRUCTURE_DIR"
        docker-compose down -v --remove-orphans
        docker system prune -f
        print_status "$GREEN" "‚úÖ Cleanup completed"
        ;;
    "help"|"--help"|"-h")
        echo "IRIS v2.0 Context Memory Infrastructure Setup Script"
        echo
        echo "Usage: $0 [command]"
        echo
        echo "Commands:"
        echo "  (no args)    Run full setup"
        echo "  check        Check system requirements"
        echo "  env          Create environment file"
        echo "  build        Build service images"
        echo "  start        Start infrastructure services"
        echo "  stop         Stop all services"
        echo "  logs         View service logs"
        echo "  health       Run health checks"
        echo "  clean        Clean up infrastructure"
        echo "  help         Show this help message"
        echo
        ;;
    *)
        main
        ;;
esac